{
  "language": "Solidity",
  "sources": {
    "contracts/dapps/IBatchExchange.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nstruct Order {\n        uint16 buyToken;\n        uint16 sellToken;\n        uint32 validFrom; // order is valid from auction collection period: validFrom inclusive\n        uint32 validUntil; // order is valid till auction collection period: validUntil inclusive\n        uint128 priceNumerator;\n        uint128 priceDenominator;\n        uint128 usedAmount; // remainingAmount = priceDenominator - usedAmount\n}\n\ninterface IBatchExchange {\n\n    function withdraw(address user, address token)\n        external;\n\n    function deposit(address token, uint256 amount)\n        external;\n\n    function getPendingWithdraw(address user, address token)\n        external\n        view\n        returns (uint256, uint32);\n\n    function getCurrentBatchId()\n        external\n        view\n        returns (uint32);\n\n    function hasValidWithdrawRequest(address user, address token)\n        external\n        view\n        returns (bool);\n\n    function tokenAddressToIdMap(address addr)\n        external\n        view\n        returns (uint16);\n\n    function orders(address userAddress)\n        external\n        view\n        returns (Order[] memory);\n\n\n    // Returns orderId\n    function placeOrder(uint16 buyToken, uint16 sellToken, uint32 validUntil, uint128 buyAmount, uint128 sellAmount)\n        external\n        returns (uint256);\n\n    function requestFutureWithdraw(address token, uint256 amount, uint32 batchId)\n        external;\n\n    function requestWithdraw(address token, uint256 amount)\n        external;\n\n}\n"
    },
    "contracts/dapps/IKyber.sol": {
      "content": "pragma solidity ^0.6.6;\n\ninterface IKyber {\n    /**\n     * @dev Makes a trade between src and dest token and send dest tokens to destAddress\n     * @param src source ERC20 token contract address\n     * @param srcAmount source ERC20 token amount in its token decimals\n     * @param dest destination ERC20 token contract address\n     * @param destAddress recipient address for destination ERC20 token\n     * @param maxDestAmount limit on the amount of destination tokens\n     * @param minConversionRate minimum conversion rate; trade is canceled if actual rate is lower\n     * @param walletId wallet address to send part of the fees to\n     * @return Amount of actual destination tokens\n     * @notice srcAmount | maxDestAmount These amounts should be in the source and\n         destination token decimals respectively. For example, if the user wants to swap\n         from / to 10 POWR,which has 6 decimals, it would be 10 * (10 ** 6) = 10000000\n     * @notice maxDestAmount should not be 0. Set it to an arbitarily large amount\n         if you want all source tokens to be converted.\n     * @notice minConversionRate: This rate is independent of the source and\n         destination token decimals. To calculate this rate, take yourRate * 10**18.\n         For example, even though ZIL has 12 token decimals, if we want the minimum\n         conversion rate to be 1 ZIL = 0.00017 ETH, then\n         minConversionRate = 0.00017 * (10 ** 18).\n     * @notice walletId: If you are part of our fee sharing program, this will be\n         your registered wallet address. Set it as 0 if you are not a participant.\n     * @notice Since ETH is not an ERC20 token, we use\n        0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee as a proxy address to represent it.\n     * @notice If src is ETH, then you also need to send ether along with your call.\n     * @notice There is a minimum trading value of 1000 wei tokens.\n        Anything fewer is considered as 0.\n     */\n    function trade(\n        address src,\n        uint256 srcAmount,\n        address dest,\n        address destAddress,\n        uint256 maxDestAmount,\n        uint256 minConversionRate,\n        address walletId\n    )\n        external\n        payable\n        returns (uint256);\n\n    /**\n     * @dev Get the expected exchange rate.\n     * @param src source ERC20 token contract address\n     * @param dest destination ERC20 token contract address\n     * @param srcQty wei amount of source ERC20 token\n     * @return The expected exchange rate and slippage rate.\n     * @notice Returned values are in precision values (10**18)\n        To understand what this rate means, divide the obtained value by 10**18\n        (tA, tB,)\n     */\n    function getExpectedRate(address src, address dest, uint256 srcQty)\n        external\n        view\n        returns (uint256, uint256);\n}\n"
    },
    "contracts/dapps/IMakerMedianizer.sol": {
      "content": "pragma solidity ^0.6.0;\n\ninterface IMedianizer {\n\n    function read() external view returns (bytes32);\n\n}\n"
    },
    "contracts/dapps/IUniswapExchange.sol": {
      "content": "pragma solidity ^0.6.6;\n\nimport \"../external/IERC20.sol\";\n\ninterface IUniswapExchange {\n    function getEthToTokenInputPrice(uint256 ethSold)\n        external\n        view\n        returns (uint256 tokensBought);\n\n    function getTokenToEthOutputPrice(uint256 ethbought)\n        external\n        view\n        returns (uint256 tokensToBeSold);\n\n    function getTokenToEthInputPrice(uint256 tokensSold)\n        external\n        view\n        returns (uint256 ethBought);\n\n    function ethToTokenSwapInput(uint256 MintTokens, uint256 deadline)\n        external\n        payable\n        returns (uint256 tokensBought);\n\n    function ethToTokenSwapOutput(uint256 tokens_bought, uint256 deadline)\n        external\n        payable\n        returns (uint256 tokensSold);\n\n    function ethToTokenTransferInput(\n        uint256 MintTokens,\n        uint256 deadline,\n        address recipient\n    ) external payable returns (uint256 tokensBought);\n\n    function tokenToEthSwapInput(\n        uint256 tokens_sold,\n        uint256 min_eth,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function tokenToEthSwapOutput(\n        uint256 eth_bought,\n        uint256 max_tokens,\n        uint256 deadline\n    ) external returns (uint256);\n\n    function tokenToTokenSwapInput(\n        uint256 tokensSold,\n        uint256 MintTokensBought,\n        uint256 minEthBought,\n        uint256 deadline,\n        address tokenAddr\n    ) external returns (uint256 tokensBought);\n\n    function tokenToEthTransferInput(\n        uint256 tokens_sold,\n        uint256 min_eth,\n        uint256 deadline,\n        address recipient\n    ) external returns (uint256);\n\n    function tokenToTokenTransferInput(\n        uint256 tokens_sold,\n        uint256 min_tokens_bought,\n        uint256 min_eth_bought,\n        uint256 deadline,\n        address recipient,\n        address token_addr\n    ) external returns (uint256);\n\n}\n"
    },
    "contracts/external/IERC20.sol": {
      "content": "pragma solidity ^0.6.6;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/dapps/IUniswapFactory.sol": {
      "content": "pragma solidity ^0.6.6;\n\nimport \"./IUniswapExchange.sol\";\n\ninterface IUniswapFactory {\n    function getExchange(IERC20 token)\n        external\n        view\n        returns (IUniswapExchange exchange);\n}\n"
    },
    "contracts/external/Address.sol": {
      "content": "pragma solidity ^0.6.6;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract's constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * IMPORTANT: It is unsafe to assume that an address for which this\n     * function returns false is an externally-owned account (EOA) and not a\n     * contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n"
    },
    "contracts/external/Ownable.sol": {
      "content": "pragma solidity ^0.6.6;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/external/SafeERC20.sol": {
      "content": "pragma solidity ^0.6.6;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/external/SafeMath.sol": {
      "content": "pragma solidity ^0.6.6;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"
    },
    "contracts/fees/FeeExtractor.sol": {
      "content": "pragma solidity ^0.6.6;\n\nimport { IUniswapFactory } from '../dapps/IUniswapFactory.sol';\nimport { IUniswapExchange } from '../dapps/IUniswapExchange.sol';\nimport { IMedianizer } from \"../dapps/IMakerMedianizer.sol\";\n\nimport { IKyber } from '../dapps/IKyber.sol';\nimport { IERC20 } from '../external/IERC20.sol';\nimport { SafeMath } from '../external/SafeMath.sol';\nimport { SafeERC20 } from '../external/SafeERC20.sol';\n\nimport { FeeFinder } from './FeeFinder.sol';\n\ncontract FeeExtractor is FeeFinder {\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // Address which receives the fee\n    address public immutable provider;\n\n    constructor(\n        address _dai,\n        address _usdt,\n        address _gusd,\n        address _tusd,\n        address _usdc,\n        address _pax,\n        address _susd,\n        address _weth,\n        address _kyberProxyAddress,\n        address _uniswapFactory,\n        address _uniswapDaiExchange,\n        address _medianizer,\n        address _provider\n    ) FeeFinder(\n        _dai,\n        _usdt,\n        _gusd,\n        _tusd,\n        _usdc,\n        _pax,\n        _susd,\n        _weth,\n        _kyberProxyAddress,\n        _uniswapFactory,\n        _uniswapDaiExchange,\n        _medianizer\n    ) public {\n        provider = _provider;\n    }\n\n    /// @dev only call into this function\n    function payFee(address _feeToken, uint256 _feeAmount)\n        external\n    {\n        require(_feeAmount != 0, \"FeeExtractor.payFee: Fee token not accepted\");\n\n        // Check if feeAmount is correct\n        require(getFeeAmount(_feeToken) == _feeAmount, \"FeeExtractor.payFee: Fee amount incorrect\");\n\n        // Transfer fee to provider\n        IERC20(_feeToken).safeTransferFrom(msg.sender, provider, _feeAmount);\n\n        // Mark that userProxy has paid for the action\n        buyCredit(msg.sender);\n    }\n}"
    },
    "contracts/fees/FeeFinder.sol": {
      "content": "pragma solidity ^0.6.6;\n\nimport { IUniswapFactory } from '../dapps/IUniswapFactory.sol';\nimport { IUniswapExchange } from '../dapps/IUniswapExchange.sol';\nimport { IMedianizer } from \"../dapps/IMakerMedianizer.sol\";\n\nimport { IKyber } from '../dapps/IKyber.sol';\nimport { IERC20 } from '../external/IERC20.sol';\nimport { SafeMath } from '../external/SafeMath.sol';\nimport { SafeERC20 } from '../external/SafeERC20.sol';\nimport { Ownable } from '../external/Ownable.sol';\n\n/// @notice Contract to set and calculate fees paid for the batchExchange withdraw action\ncontract FeeFinder is Ownable {\n\n    using SafeMath for uint256;\n\n    // Fee\n    uint256 public constant feeDAI = 3; //DAI\n    uint256 public constant feeDAIWei = 3 ether; //DAI\n\n    mapping(address => uint256) public proxyHasPaidForAction;\n    // Stores the prepayment amount in DAI for a certain action\n    mapping(address => uint256) public prepaymentAmount;\n\n\n    // Hardcoded Tokens\n    address public immutable DAI;\n    address public immutable GUSD;\n    address public immutable USDT;\n    address public immutable TUSD;\n    address public immutable USDC;\n    address public immutable PAX;\n    address public immutable sUSD;\n    address public immutable WETH;\n\n    // DEXs\n    IKyber public immutable kyber;\n    IUniswapExchange public immutable uniswapDaiExchange;\n    IUniswapFactory public immutable uniswapFactory;\n    // Maker Medianizer for WETH Exchange Rate\n    IMedianizer private immutable medianizer;\n\n    constructor(\n        address _dai,\n        address _usdt,\n        address _gusd,\n        address _tusd,\n        address _usdc,\n        address _pax,\n        address _susd,\n        address _weth,\n        address _kyberProxyAddress,\n        address _uniswapFactory,\n        address _uniswapDaiExchange,\n        address _medianizer\n    ) public {\n\n        // Token Configuration\n        DAI = _dai;\n        GUSD = _gusd;\n        USDT = _usdt;\n        TUSD = _tusd;\n        USDC = _usdc;\n        PAX = _pax;\n        sUSD = _susd;\n        WETH = _weth;\n\n        // Exchange Configuration\n        kyber = IKyber(_kyberProxyAddress);\n        uniswapFactory = IUniswapFactory(_uniswapFactory);\n        uniswapDaiExchange = IUniswapExchange(_uniswapDaiExchange);\n        medianizer = IMedianizer(_medianizer);\n    }\n\n\n    function buyCredit(address _payer) internal {\n        proxyHasPaidForAction[_payer] += 1;\n    }\n\n    function proxyHasCredit(address _payer)\n        external\n        view\n        returns (bool userHasCredit)\n    {\n        userHasCredit = proxyHasPaidForAction[_payer] > 0 ? true : false;\n    }\n\n    function redeemCredit() external {\n        proxyHasPaidForAction[msg.sender] = proxyHasPaidForAction[msg.sender].sub(1,\n        \"FeeFinder: All credit used up\");\n    }\n\n\n    /// @notice Is the inputted _feeToken accepted in this smart contract?\n    /// @dev Off-chain API for UIs to see if _feeToken is accepted by smart contract\n    /// @param _feeToken token held in proxy contract that will used to pay the fees to the provider\n    function isFeeTokenEligible(address _feeToken) view public returns(bool feeTokenAccepted) {\n        uint256 feeAmount = getFeeAmount(_feeToken);\n        feeTokenAccepted = feeAmount == 0 ?  false : true;\n    }\n\n    /// @notice Get the fee amount based on the inputted fee token\n    /// @dev Returns 0 if no matching fee token was found\n    /// @param _feeToken token held in proxy contract that will used to pay the fees to the provider\n    function getFeeAmount(address _feeToken) view public returns(uint256 feeAmount) {\n        feeAmount = checkHardcodedTokens(_feeToken);\n        if(feeAmount == 0) feeAmount = getUniswapRate(_feeToken);\n        if(feeAmount == 0) feeAmount = getKyberRate(_feeToken);\n    }\n\n    function checkHardcodedTokens(address _feeToken) view public returns(uint256 feeAmount) {\n        if (_feeToken == DAI) feeAmount = feeDAI*10**18;\n        if (_feeToken == USDT) feeAmount = feeDAI*10**6;\n        if (_feeToken == GUSD) feeAmount = feeDAI*10**2;\n        if (_feeToken == TUSD) feeAmount = feeDAI*10**18;\n        if (_feeToken == USDC) feeAmount = feeDAI*10**6;\n        if (_feeToken == PAX) feeAmount = feeDAI*10**18;\n        if (_feeToken == sUSD) feeAmount = feeDAI*10**18;\n        if (_feeToken == WETH) feeAmount = getMakerEthOracleRate();\n    }\n\n    function getUniswapRate(address _feeToken) view public returns(uint256 feeAmount) {\n        IUniswapExchange feeTokenExchange = uniswapFactory.getExchange(IERC20(_feeToken));\n        if(feeTokenExchange != IUniswapExchange(0)) {\n            // 1. Get Price of X DAI to ETH\n            try uniswapDaiExchange.getTokenToEthInputPrice(feeDAIWei)\n                returns(uint256 _daiValueInEth)\n            {\n                try feeTokenExchange.getEthToTokenInputPrice(_daiValueInEth)\n                    returns(uint256 _ethValueInFeeToken)\n                {\n                    feeAmount = _ethValueInFeeToken;\n\n                } catch {feeAmount = 0;}\n\n            } catch {feeAmount = 0;}\n        }\n    }\n\n    function getKyberRate(address _feeToken) view public returns(uint256 feeAmount) {\n        uint256 decimals = getDecimals(_feeToken);\n\n        if (decimals != 0) {\n            try kyber.getExpectedRate(DAI, _feeToken, feeAmount)\n                returns(uint256 expectedRate, uint256)\n            {\n                if (expectedRate != 0) {\n                    // 18 == daiDecimals\n                    uint256 decimalFactor = (10 ** 18) / (10 ** decimals);\n                    feeAmount = expectedRate.mul(feeDAI).div(decimalFactor);\n                } else feeAmount = 0;\n            } catch {\n                feeAmount = 0;\n            }\n        }\n    }\n\n    function getMakerEthOracleRate() view public returns(uint256 feeAmount) {\n        uint256 ethPrice = uint256(medianizer.read());\n        feeAmount = 10**18  * feeDAIWei / ethPrice;\n    }\n\n    function getDecimals(address _feeToken)\n        internal\n        view\n        returns(uint256)\n    {\n        (bool success, bytes memory data) = address(_feeToken).staticcall{gas: 20000}(\n            abi.encodeWithSignature(\"decimals()\")\n        );\n\n        if (!success) {\n            (success, data) = address(_feeToken).staticcall{gas: 20000}(\n                abi.encodeWithSignature(\"DECIMALS()\")\n            );\n        }\n\n        if (success) {\n            return abi.decode(data, (uint256));\n        } else {\n            return 0;\n        }\n    }\n}"
    },
    "contracts/gelato/GelatoActionsStandard.sol": {
      "content": "pragma solidity ^0.6.6;\n\nimport \"./IGelatoAction.sol\";\n\n/// @title GelatoActionsStandard\n/// @dev find all the NatSpecs inside IGelatoAction\nabstract contract GelatoActionsStandard is IGelatoAction {\n\n    string internal constant OK = \"OK\";\n\n    function termsOk(address, bytes calldata)  // _userProxy, _actionData\n        external\n        view\n        override\n        virtual\n        returns(string memory)  // actionTermsOk\n    {\n        // Standard return value for actionConditions fulfilled and no erros:\n        return OK;\n    }\n}\n"
    },
    "contracts/gelato/IGelatoAction.sol": {
      "content": "pragma solidity ^0.6.6;\n\n/// @title IGelatoAction - solidity interface of GelatoActionsStandard\n/// @notice all the APIs and events of GelatoActionsStandard\n/// @dev all the APIs are implemented inside GelatoActionsStandard\ninterface IGelatoAction {\n    event LogOneWay(\n        address origin,\n        address sendToken,\n        uint256 sendAmount,\n        address destination\n    );\n\n    event LogTwoWay(\n        address origin,\n        address sendToken,\n        uint256 sendAmount,\n        address destination,\n        address receiveToken,\n        uint256 receiveAmount,\n        address receiver\n    );\n\n\n    function termsOk(address _userProxy, bytes calldata _actionData)\n        external\n        view\n        returns(string memory);\n}\n"
    },
    "contracts/gelato/IGelatoCondition.sol": {
      "content": "pragma solidity ^0.6.6;\npragma experimental ABIEncoderV2;\n\n/// @title IGelatoCondition - solidity interface of GelatoConditionsStandard\n/// @notice all the APIs of GelatoConditionsStandard\n/// @dev all the APIs are implemented inside GelatoConditionsStandard\ninterface IGelatoCondition {\n    function ok(bytes calldata _conditionData) external view returns(string memory);\n    function okStandardSelector() external pure returns(bytes4);\n}"
    },
    "contracts/gelato/IGelatoCore.sol": {
      "content": "pragma solidity ^0.6.6;\npragma experimental ABIEncoderV2;\n\nimport { IGelatoProviderModule } from \"./IGelatoProviderModule.sol\";\nimport { IGelatoCondition } from \"./IGelatoCondition.sol\";\n\nstruct Provider {\n    address addr;  //  if msg.sender == provider => self-Provider\n    IGelatoProviderModule module;  //  can be IGelatoProviderModule(0) for self-Providers\n}\n\nstruct Condition {\n    IGelatoCondition inst;  // can be AddressZero for self-conditional Actions\n    bytes data;  // can be bytes32(0) for self-conditional Actions\n}\n\nenum Operation { Call, Delegatecall }\n\nstruct Action {\n    address addr;\n    bytes data;\n    Operation operation;\n    uint256 value;\n    bool termsOkCheck;\n}\n\nstruct Task {\n    Provider provider;\n    Condition[] conditions;  // optional\n    Action[] actions;\n    uint256 expiryDate;  // 0 == infinity.\n    bool autoSubmitNextTask;  // optional for infinite automation\n}\n\nstruct TaskReceipt {\n    uint256 id;\n    address userProxy;\n    Task task;\n}\n\ninterface IGelatoCore {\n    event LogTaskSubmitted(\n        uint256 indexed taskReceiptId,\n        bytes32 indexed taskReceiptHash,\n        TaskReceipt taskReceipt\n    );\n\n    event LogExecSuccess(\n        address indexed executor,\n        uint256 indexed taskReceiptId,\n        uint256 executorSuccessFee,\n        uint256 sysAdminSuccessFee\n    );\n    event LogCanExecFailed(\n        address indexed executor,\n        uint256 indexed taskReceiptId,\n        string reason\n    );\n    event LogExecReverted(\n        address indexed executor,\n        uint256 indexed taskReceiptId,\n        uint256 executorRefund,\n        string reason\n    );\n\n    event LogTaskCancelled(uint256 indexed taskReceiptId);\n\n    function canSubmitTask(address _userProxy, Task calldata _task)\n        external\n        view\n        returns(string memory);\n\n    /// @notice Submit a gelato task that will be executed under the specified conditions\n    /// @dev This function must be called from a contract account provided by Provider\n    /// @param _task Selected provider, conditions, actions, expiry date of the task\n    function submitTask(Task calldata _task) external;\n\n    /// @notice Submit a gelato task that will be executed under the specified conditions\n    /// @dev This function must be called from a contract account provided by Provider\n    /// @param _tasks Selected provider, conditions, actions, expiry date of the task\n    function multiSubmitTasks(Task[] calldata _tasks) external;\n\n\n    // ================  Exec Suite =========================\n    /// @notice Off-chain API for executors to check, if a TaskReceipt is executable\n    /// @dev GelatoCore checks this during execution, in order to safeguard the Conditions\n    /// @param _TR TaskReceipt, consisting of user task, user proxy address and id\n    /// @param _gelatoMaxGas If  this is used by an Executor and a revert happens,\n    ///  the Executor gets a refund from the Provider and the TaskReceipt is annulated.\n    /// @param _execTxGasPrice Must be used by Executors. Gas Price fed by gelatoCore's\n    ///  Gas Price Oracle. Executors can query the current gelatoGasPrice from events.\n    function canExec(TaskReceipt calldata _TR, uint256 _gelatoMaxGas, uint256 _execTxGasPrice)\n        external\n        view\n        returns(string memory);\n\n    /// @notice Executors call this when Conditions allow it to execute submitted Tasks.\n    /// @dev Executors get rewarded for successful Execution. The Task remains open until\n    ///   successfully executed, or when the execution failed, despite of gelatoMaxGas usage.\n    ///   In the latter case Executors are refunded by the Task Provider.\n    /// @param _TR TaskReceipt: id, userProxy, Task.\n    function exec(TaskReceipt calldata _TR) external;\n\n    /// @notice Cancel task\n    /// @dev Callable only by userProxy or selected provider\n    /// @param _TR TaskReceipt: id, userProxy, Task.\n    function cancelTask(TaskReceipt calldata _TR) external;\n\n    /// @notice Batch Cancel tasks\n    /// @dev Callable only by userProxy or selected provider\n    /// @param _taskReceipts TaskReceipts: id, userProxy, Task.\n    function multiCancelTasks(TaskReceipt[] calldata _taskReceipts) external;\n\n    /// @notice Compute hash of task receipt\n    /// @param _TR TaskReceipt, consisting of user task, user proxy address and id\n    /// @return hash of taskReceipt\n    function hashTaskReceipt(TaskReceipt calldata _TR) external pure returns(bytes32);\n\n    // ================  Getters =========================\n    /// @notice Returns the taskReceiptId of the last TaskReceipt submitted\n    /// @return currentId currentId, last TaskReceiptId submitted\n    function currentTaskReceiptId() external view returns(uint256 currentId);\n\n    /// @notice Returns computed taskReceipt hash, used to check for taskReceipt validity\n    /// @param _taskReceiptId Id of taskReceipt emitted in submission event\n    /// @return hash of taskReceipt\n    function taskReceiptHash(uint256 _taskReceiptId) external view returns(bytes32);\n\n}\n"
    },
    "contracts/gelato/IGelatoProviderModule.sol": {
      "content": "pragma solidity ^0.6.6;\npragma experimental ABIEncoderV2;\n\nimport { Action, Task } from \"./IGelatoCore.sol\";\n\ninterface IGelatoProviderModule {\n\n    /// @notice Check if provider agrees to pay for inputted task receipt\n    /// @dev Enables arbitrary checks by provider\n    /// @param _userProxy userProxy\n    /// @param _task Task\n    /// @return \"OK\" if provider agrees\n    function isProvided(address _userProxy, Task calldata _task)\n        external\n        view\n        returns(string memory);\n\n    /// @notice Convert action specific payload into proxy specific payload\n    /// @dev Encoded multiple actions into a multisend\n    /// @param _actions List of actions to execute\n    /// @return Encoded payload that will be used for low-level .call on user proxy\n    /// @return checkReturndata if true, fwd returndata from userProxy.call to ProviderModule\n    function execPayload(Action[] calldata _actions)\n        external\n        view\n        returns(bytes memory, bool checkReturndata);\n\n    function execRevertCheck(bytes calldata _proxyReturndata)\n        external\n        view\n        returns(bool);\n}\n"
    },
    "contracts/gnosis/ActionPlaceOrderBatchExchange.sol": {
      "content": "pragma solidity ^0.6.5;\npragma experimental ABIEncoderV2;\n\nimport { GelatoActionsStandard } from \"../gelato/GelatoActionsStandard.sol\";\nimport { IGelatoAction } from \"../gelato/IGelatoAction.sol\";\nimport { IERC20 } from \"../external/IERC20.sol\";\nimport { SafeERC20 } from \"../external/SafeERC20.sol\";\nimport { SafeMath } from \"../external/SafeMath.sol\";\nimport { IBatchExchange } from \"..//dapps/IBatchExchange.sol\";\nimport { Task, IGelatoCore } from \"../gelato/IGelatoCore.sol\";\nimport { FeeExtractor } from \"../fees/FeeExtractor.sol\";\n\n\n\n/// @title ActionPlaceOrderBatchExchange\n/// @author Luis Schliesske & Hilmar Orth\n/// @notice Gelato action that 1) withdraws funds form user's  EOA, 2) deposits on Batch Exchange, 3) Places order on batch exchange and 4) requests future withdraw on batch exchange\n\ncontract ActionPlaceOrderBatchExchange  {\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant MAX_UINT = uint256(-1);\n    uint32 public constant BATCH_TIME = 300;\n\n    IBatchExchange private immutable batchExchange;\n\n    constructor(address _batchExchange) public {\n        batchExchange = IBatchExchange(_batchExchange);\n    }\n\n    /// @notice Place order on Batch Exchange and request future withdraw for buy and sell token\n    /// @param _user Users EOA address\n    /// @param _sellToken Token to sell on Batch Exchange\n    /// @param _buyToken Token to buy on Batch Exchange\n    /// @param _sellAmount Amount to sell\n    /// @param _buyAmount Amount to receive (at least)\n    /// @param _batchDuration After how many batches funds should be\n    function action(\n        address _user,\n        address _sellToken,\n        address _buyToken,\n        uint128 _sellAmount,\n        uint128 _buyAmount,\n        uint32 _batchDuration\n    )\n        public\n        virtual\n    {\n\n        // 1. Transfer sellToken to proxy\n        IERC20 sellToken = IERC20(_sellToken);\n        sellToken.safeTransferFrom(_user, address(this), _sellAmount);\n\n\n        // 2. Fetch token Ids for sell & buy token on Batch Exchange\n        uint16 sellTokenId = batchExchange.tokenAddressToIdMap(_sellToken);\n        uint16 buyTokenId = batchExchange.tokenAddressToIdMap(_buyToken);\n\n        // 3. Approve sellToken to BatchExchange Contract\n        sellToken.safeIncreaseAllowance(address(batchExchange), _sellAmount);\n\n        // 4. Deposit sellAmount on BatchExchange\n        try batchExchange.deposit(_sellToken, _sellAmount) {}\n        catch {\n            revert(\"batchExchange.deposit _sellToken failed\");\n        }\n\n        // Get current batch id\n        uint32 withdrawBatchId = uint32(now / BATCH_TIME) + _batchDuration;\n\n        // 5. Place Order on Batch Exchange\n        // uint16 buyToken, uint16 sellToken, uint32 validUntil, uint128 buyAmount, uint128 sellAmount\n        try batchExchange.placeOrder(buyTokenId, sellTokenId, withdrawBatchId, _buyAmount, _sellAmount) {}\n        catch {\n            revert(\"batchExchange.placeOrderfailed\");\n        }\n\n        // 6. Request future withdraw on Batch Exchange for sellToken\n        // requestFutureWithdraw(address token, uint256 amount, uint32 batchId)\n        try batchExchange.requestFutureWithdraw(_sellToken, _sellAmount, withdrawBatchId) {}\n        catch {\n            revert(\"batchExchange.requestFutureWithdraw _sellToken failed\");\n        }\n\n        // 7. Request future withdraw on Batch Exchange for sellToken\n        // @DEV using MAX_UINT as we don't know in advance how much buyToken we will get\n        // requestFutureWithdraw(address token, uint256 amount, uint32 batchId)\n        try batchExchange.requestFutureWithdraw(_buyToken, MAX_UINT, withdrawBatchId) {}\n        catch {\n            revert(\"batchExchange.requestFutureWithdraw _buyToken failed\");\n        }\n\n    }\n\n    // ======= ACTION CONDITIONS CHECK =========\n    // Overriding and extending GelatoActionsStandard's function (optional)\n    function termsOk(address _userProxy, bytes calldata _actionData)\n        external\n        view\n        virtual\n        returns(string memory)  // actionCondition\n    {\n        (address _user,\n        address _sellToken,\n        ,\n        uint128 _sellAmount,\n        ,\n        ) = abi.decode(_actionData[4:], (address, address, address, uint128, uint128, uint32));\n        return _actionProviderTermsCheck(_user, _userProxy, _sellToken, _sellAmount);\n    }\n\n    /// @notice Verify that EOA has sufficinet balance and gave proxy adequate allowance\n    /// @param _user Users EOA address\n    /// @param _userProxy Users Proxy address\n    /// @param _sellToken Token to sell on Batch Exchange\n    /// @param _sellAmount Amount to sell\n    function _actionProviderTermsCheck(\n        address _user, address _userProxy, address _sellToken, uint128 _sellAmount\n    )\n        internal\n        view\n        virtual\n        returns(string memory)  // actionCondition\n    {\n        IERC20 sendERC20 = IERC20(_sellToken);\n        try sendERC20.balanceOf(_user) returns(uint256 sendERC20Balance) {\n            if (sendERC20Balance < _sellAmount)\n                return \"ActionPlaceOrderBatchExchange: NotOkUserSendTokenBalance\";\n        } catch {\n            return \"ActionPlaceOrderBatchExchange: ErrorBalanceOf\";\n        }\n        try sendERC20.allowance(_user, _userProxy)\n            returns(uint256 userProxySendTokenAllowance)\n        {\n            if (userProxySendTokenAllowance < _sellAmount)\n                return \"ActionPlaceOrderBatchExchange: NotOkUserProxySendTokenAllowance\";\n        } catch {\n            return \"ActionPlaceOrderBatchExchange: ErrorAllowance\";\n        }\n\n        // STANDARD return string to signal actionConditions Ok\n        return \"OK\";\n    }\n\n\n}"
    },
    "contracts/gnosis/ActionPlaceOrderBatchExchangePayFee.sol": {
      "content": "pragma solidity ^0.6.5;\npragma experimental ABIEncoderV2;\n\nimport { GelatoActionsStandard } from \"../gelato/GelatoActionsStandard.sol\";\nimport { IGelatoAction } from \"../gelato/IGelatoAction.sol\";\nimport { IERC20 } from \"../external/IERC20.sol\";\nimport { SafeERC20 } from \"../external/SafeERC20.sol\";\nimport { SafeMath } from \"../external/SafeMath.sol\";\nimport { IBatchExchange } from \"..//dapps/IBatchExchange.sol\";\nimport { Task, IGelatoCore } from \"../gelato/IGelatoCore.sol\";\nimport { FeeExtractor } from \"../fees/FeeExtractor.sol\";\n\n\n\n/// @title ActionPlaceOrderBatchExchangePayFee\n/// @author Luis Schliesske & Hilmar Orth\n/// @notice Gelato action that 1) executes PlaceOrder on Batch Exchange, 2) buys withdraw credit from provider and 3) creates withdraw task on gelato\n\ncontract ActionPlaceOrderBatchExchangePayFee  {\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant MAX_UINT = uint256(-1);\n    uint32 public constant BATCH_TIME = 300;\n\n    IBatchExchange public immutable batchExchange;\n    FeeExtractor public immutable feeExtractor;\n\n    constructor(address _batchExchange, address _feeExtractor) public {\n        batchExchange = IBatchExchange(_batchExchange);\n        feeExtractor = FeeExtractor(_feeExtractor);\n    }\n\n    /// @notice Place order on Batch Exchange and request future withdraw for buy and sell token\n    /// @param _user Users EOA address\n    /// @param _sellToken Token to sell on Batch Exchange\n    /// @param _buyToken Token to buy on Batch Exchange\n    /// @param _sellAmount Amount to sell\n    /// @param _buyAmount Amount to receive (at least)\n    /// @param _batchDuration After how many batches funds should be\n    function action(\n        address _user,\n        address _sellToken,\n        address _buyToken,\n        uint128 _sellAmount,\n        uint128 _buyAmount,\n        uint32 _batchDuration\n    )\n        public\n        virtual\n    {\n        /*\n        - [ ] a) transferFrom an ERC20 from the proxies owner account to the proxy,\n        - [ ] b) calls deposit  token in EpochTokenLocker contract\n        - [ ] c) calls placeOrder in BatchExchange contract, inputting valid until 3 auctions from current one\n        - [ ] d) calls requestFutureWithdraw with batch id of the n + 3 and amount arbitrary high (higher than expected output) contract in EpochTokenLocker\n        - [ ] e) submits a task on gelato with condition = address(0) and action withdraw() in EpochTokenLocker contract\n        */\n\n        // 1. Transfer sellToken to proxy\n        IERC20 sellToken = IERC20(_sellToken);\n        sellToken.safeTransferFrom(_user, address(this), _sellAmount);\n\n        // 2. Pay fee to provider\n        uint256 fee = feeExtractor.getFeeAmount(_sellToken);\n        sellToken.safeIncreaseAllowance(address(feeExtractor), fee);\n        feeExtractor.payFee(_sellToken, fee);\n        // Deduct fee from sell amount\n        _sellAmount -= uint128(fee);\n\n\n        // 2. Fetch token Ids for sell & buy token on Batch Exchange\n        uint16 sellTokenId = batchExchange.tokenAddressToIdMap(_sellToken);\n        uint16 buyTokenId = batchExchange.tokenAddressToIdMap(_buyToken);\n\n        // 3. Approve sellToken to BatchExchange Contract\n        sellToken.safeIncreaseAllowance(address(batchExchange), _sellAmount);\n\n        // 4. Deposit sellAmount on BatchExchange\n        try batchExchange.deposit(_sellToken, _sellAmount) {}\n        catch {\n            revert(\"batchExchange.deposit _sellToken failed\");\n        }\n\n        // Get current batch id\n        uint32 withdrawBatchId = uint32(now / BATCH_TIME) + _batchDuration;\n\n        // 5. Place Order on Batch Exchange\n        // uint16 buyToken, uint16 sellToken, uint32 validUntil, uint128 buyAmount, uint128 sellAmount\n        try batchExchange.placeOrder(buyTokenId, sellTokenId, withdrawBatchId, _buyAmount, _sellAmount) {}\n        catch {\n            revert(\"batchExchange.placeOrderfailed\");\n        }\n\n        // 6. Request future withdraw on Batch Exchange for sellToken\n        // requestFutureWithdraw(address token, uint256 amount, uint32 batchId)\n        try batchExchange.requestFutureWithdraw(_sellToken, _sellAmount, withdrawBatchId) {}\n        catch {\n            revert(\"batchExchange.requestFutureWithdraw _sellToken failed\");\n        }\n\n        // 7. Request future withdraw on Batch Exchange for sellToken\n        // @DEV using MAX_UINT as we don't know in advance how much buyToken we will get\n        // requestFutureWithdraw(address token, uint256 amount, uint32 batchId)\n        try batchExchange.requestFutureWithdraw(_buyToken, MAX_UINT, withdrawBatchId) {}\n        catch {\n            revert(\"batchExchange.requestFutureWithdraw _buyToken failed\");\n        }\n\n    }\n\n    // ======= ACTION CONDITIONS CHECK =========\n    // Overriding and extending GelatoActionsStandard's function (optional)\n    function termsOk(address _userProxy, bytes calldata _actionData)\n        external\n        view\n        virtual\n        returns(string memory)  // actionCondition\n    {\n        (address _user, address _sellToken, , uint128 _sellAmount, , , ,) = abi.decode(_actionData[4:], (address, address, address, uint128, uint128, uint32, address, Task));\n        return _actionProviderTermsCheck(_user, _userProxy, _sellToken, _sellAmount);\n    }\n\n    /// @notice Verify that EOA has sufficinet balance and gave proxy adequate allowance\n    /// @param _user Users EOA address\n    /// @param _userProxy Users Proxy address\n    /// @param _sellToken Token to sell on Batch Exchange\n    /// @param _sellAmount Amount to sell\n    function _actionProviderTermsCheck(\n        address _user, address _userProxy, address _sellToken, uint128 _sellAmount\n    )\n        internal\n        view\n        virtual\n        returns(string memory)  // actionCondition\n    {\n        IERC20 sendERC20 = IERC20(_sellToken);\n        try sendERC20.balanceOf(_user) returns(uint256 sendERC20Balance) {\n            if (sendERC20Balance < _sellAmount)\n                return \"ActionPlaceOrderBatchExchange: NotOkUserSendTokenBalance\";\n        } catch {\n            return \"ActionPlaceOrderBatchExchange: ErrorBalanceOf\";\n        }\n        try sendERC20.allowance(_user, _userProxy)\n            returns(uint256 userProxySendTokenAllowance)\n        {\n            if (userProxySendTokenAllowance < _sellAmount)\n                return \"ActionPlaceOrderBatchExchange: NotOkUserProxySendTokenAllowance\";\n        } catch {\n            return \"ActionPlaceOrderBatchExchange: ErrorAllowance\";\n        }\n\n        // STANDARD return string to signal actionConditions Ok\n        return \"OK\";\n    }\n\n\n}"
    },
    "contracts/gnosis/ActionWithdrawBatchExchange.sol": {
      "content": "pragma solidity ^0.6.5;\n\nimport { GelatoActionsStandard } from \"../gelato/GelatoActionsStandard.sol\";\nimport { IGelatoAction } from \"../gelato/IGelatoAction.sol\";\nimport { IERC20 } from \"../external/IERC20.sol\";\nimport { SafeERC20 } from \"../external/SafeERC20.sol\";\nimport { SafeMath } from \"../external/SafeMath.sol\";\nimport { IBatchExchange } from \"..//dapps/IBatchExchange.sol\";\nimport { Task, IGelatoCore } from \"../gelato/IGelatoCore.sol\";\nimport { FeeExtractor } from \"../fees/FeeExtractor.sol\";\n\n\n/// @title ActionWithdrawBatchExchange\n/// @author Luis Schliesske & Hilmar Orth\n/// @notice Gelato action that 1) withdraws funds from Batch Exchange and 2) sends funds back to users EOA (minus fee)\ncontract ActionWithdrawBatchExchange is GelatoActionsStandard {\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // BatchExchange\n    IBatchExchange public immutable batchExchange;\n\n    // Fee finder\n    FeeExtractor public immutable feeExtractor;\n\n    constructor(address _batchExchange, address _feeExtractor) public {\n        batchExchange = IBatchExchange(_batchExchange);\n        feeExtractor = FeeExtractor(_feeExtractor);\n    }\n\n    /// @notice Withdraw sell and buy token from Batch Exchange and send funds back to _user EOA\n    /// @param _sellToken Token to sell on Batch Exchange\n    /// @param _buyToken Token to buy on Batch Exchange\n    function action(\n        address _user,\n        address _sellToken,\n        address _buyToken\n    )\n        public\n        virtual\n    {\n\n        // 1. Withdraw buy tokens\n        IERC20 buyToken = IERC20(_buyToken);\n        uint256 preBuyTokenBalance = buyToken.balanceOf(address(this));\n        try batchExchange.withdraw(address(this), _buyToken) {\n            uint256 postBuyTokenBalance = buyToken.balanceOf(address(this));\n            if (postBuyTokenBalance > preBuyTokenBalance) {\n                uint256 withdrawAmount = postBuyTokenBalance - preBuyTokenBalance;\n                buyToken.safeTransfer(_user, withdrawAmount);\n            }\n        }\n        catch {\n           // Do not revert, as order might not have been fulfilled.\n           revert(\"ActionWithdrawBatchExchange.withdraw _buyToken failed\");\n        }\n\n        // 5. Withdraw sell tokens\n        IERC20 sellToken = IERC20(_sellToken);\n        uint256 preSellTokenBalance = sellToken.balanceOf(address(this));\n        try batchExchange.withdraw(address(this), _sellToken) {\n            uint256 postSellTokenBalance = sellToken.balanceOf(address(this));\n            if (postSellTokenBalance > preSellTokenBalance) {\n                uint256 withdrawAmount = postSellTokenBalance - preSellTokenBalance;\n                sellToken.safeTransfer(_user, withdrawAmount);\n            }\n        }\n        catch {\n            // Do not revert, as order might have been filled completely\n            revert(\"ActionWithdrawBatchExchange.withdraw _sellToken failed\");\n        }\n\n    }\n\n    // ======= ACTION CONDITIONS CHECK =========\n    // Overriding and extending GelatoActionsStandard's function (optional)\n    function termsOk(address _userProxy, bytes calldata _actionData)\n        external\n        view\n        override\n        virtual\n        returns(string memory)  // actionCondition\n    {\n        (, address _sellToken, address _buyToken) = abi.decode(\n            _actionData[4:],\n            (address,address,address)\n        );\n        return termsOk(_userProxy, _sellToken, _buyToken);\n    }\n\n    /// @notice Verify that _userProxy has two valid withdraw request on batch exchange (for buy and sell token)\n    /// @param _userProxy Users Proxy address\n    /// @param _sellToken Token to sell on Batch Exchange\n    /// @param _buyToken Amount to sell\n    function termsOk(address _userProxy, address _sellToken, address _buyToken)\n        public\n        view\n        virtual\n        returns(string memory)  // actionCondition\n    {\n        bool sellTokenWithdrawable = batchExchange.hasValidWithdrawRequest(_userProxy, _sellToken);\n\n        if (!sellTokenWithdrawable)\n            return \"ActionWithdrawBatchExchange: Sell Token not withdrawable yet\";\n\n        bool buyTokenWithdrawable = batchExchange.hasValidWithdrawRequest(_userProxy, _buyToken);\n\n        if (!buyTokenWithdrawable)\n            return \"ActionWithdrawBatchExchange: Buy Token not withdrawable yet\";\n\n        bool proxyHasCredit = feeExtractor.proxyHasCredit(_userProxy);\n\n        if (!proxyHasCredit)\n            return \"ActionWithdrawBatchExchange: Proxy has insufficient credit\";\n\n        return OK;\n    }\n}"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}